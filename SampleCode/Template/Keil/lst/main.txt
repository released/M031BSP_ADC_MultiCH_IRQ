; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC_IRQHandler PROC
;;;122    
;;;123    void ADC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125    	uint8_t ch_idx = 0;
000002  2000              MOVS     r0,#0
;;;126    
;;;127    	for (ch_idx = 0 ; adc_data[ch_idx].idx < 0xFF ; ch_idx++)
;;;128    	{
;;;129    		if (aADCxCH == adc_data[ch_idx].adc_ch)
000004  4b0d              LDR      r3,|L1.60|
000006  4a0e              LDR      r2,|L1.64|
000008  e006              B        |L1.24|
                  |L1.10|
00000a  1889              ADDS     r1,r1,r2
00000c  7849              LDRB     r1,[r1,#1]
00000e  885c              LDRH     r4,[r3,#2]  ; aADCxCH
000010  42a1              CMP      r1,r4
000012  d005              BEQ      |L1.32|
000014  1c40              ADDS     r0,r0,#1
000016  b2c0              UXTB     r0,r0                 ;127
                  |L1.24|
000018  0041              LSLS     r1,r0,#1              ;127
00001a  5c54              LDRB     r4,[r2,r1]            ;127
00001c  2cff              CMP      r4,#0xff              ;127
00001e  d3f4              BCC      |L1.10|
                  |L1.32|
;;;130    		{
;;;131    			break;
;;;132    		}
;;;133    		else
;;;134    		{
;;;135    			continue;
;;;136    		}
;;;137    	}
;;;138    	ADCxConvertedData[ch_idx] = ADC_GET_CONVERSION_DATA(ADC, aADCxCH);
000020  8859              LDRH     r1,[r3,#2]  ; aADCxCH
000022  4a08              LDR      r2,|L1.68|
000024  0089              LSLS     r1,r1,#2
000026  1889              ADDS     r1,r1,r2
000028  6809              LDR      r1,[r1,#0]
00002a  4a04              LDR      r2,|L1.60|
00002c  0040              LSLS     r0,r0,#1
00002e  320c              ADDS     r2,r2,#0xc
000030  5211              STRH     r1,[r2,r0]
;;;139    	
;;;140        ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT); /* Clear the A/D interrupt flag */
000032  4904              LDR      r1,|L1.68|
000034  2001              MOVS     r0,#1
000036  3180              ADDS     r1,r1,#0x80
000038  6108              STR      r0,[r1,#0x10]
;;;141    }
00003a  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L1.60|
                          DCD      ||.data||
                  |L1.64|
                          DCD      ||.constdata||
                  |L1.68|
                          DCD      0x40043000

                          AREA ||i.ADC_InitChannel||, CODE, READONLY, ALIGN=2

                  ADC_InitChannel PROC
;;;173    
;;;174    void ADC_InitChannel(uint8_t ch)
000000  b5f8              PUSH     {r3-r7,lr}
;;;175    {
;;;176    //	ADC_ReadAVdd();
;;;177    
;;;178    //    /* Enable ADC converter */
;;;179    //    ADC_POWER_ON(ADC);
;;;180    
;;;181    //    /*Wait for ADC internal power ready*/
;;;182    //    CLK_SysTickDelay(10000);
;;;183    
;;;184        /* Set input mode as single-end, and Single mode*/
;;;185        ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE,(uint32_t) 0x1 << ch);//BIT0|BIT4
000002  2601              MOVS     r6,#1
000004  4633              MOV      r3,r6
000006  4083              LSLS     r3,r3,r0
000008  4f0e              LDR      r7,|L2.68|
00000a  2200              MOVS     r2,#0
00000c  461d              MOV      r5,r3
00000e  4611              MOV      r1,r2
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       ADC_Open
;;;186    
;;;187        /* To sample band-gap precisely, the ADC capacitor must be charged at least 3 us for charging the ADC capacitor ( Cin )*/
;;;188        /* Sampling time = extended sampling time + 1 */
;;;189        /* 1/24000000 * (Sampling time) = 3 us */
;;;190    	/*
;;;191    	    printf("+----------------------------------------------------------------------+\n");
;;;192    	    printf("|   ADC clock source -> PCLK1  = 48 MHz                                |\n");
;;;193    	    printf("|   ADC clock divider          = 2                                     |\n");
;;;194    	    printf("|   ADC clock                  = 48 MHz / 2 = 24 MHz                   |\n");
;;;195    	    printf("|   ADC extended sampling time = 71                                    |\n");
;;;196    	    printf("|   ADC conversion time = 17 + ADC extended sampling time = 88         |\n");
;;;197    	    printf("|   ADC conversion rate = 24 MHz / 88 = 272.7 ksps                     |\n");
;;;198    	    printf("+----------------------------------------------------------------------+\n");
;;;199    	*/
;;;200    
;;;201        /* Set extend sampling time based on external resistor value.*/
;;;202        ADC_SetExtendSampleTime(ADC,(uint32_t) NULL, ADCextendSampling);
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       ADC_SetExtendSampleTime
;;;203    
;;;204        /* Select ADC input channel */
;;;205        ADC_SET_INPUT_CHANNEL(ADC, 0x1 << ch);
000020  4c08              LDR      r4,|L2.68|
000022  3480              ADDS     r4,r4,#0x80
000024  6860              LDR      r0,[r4,#4]
000026  6065              STR      r5,[r4,#4]
;;;206    
;;;207    	ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
000028  6126              STR      r6,[r4,#0x10]
;;;208    	ADC_ENABLE_INT(ADC, ADC_ADF_INT);
00002a  2101              MOVS     r1,#1
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       ADC_EnableInt
000032  4905              LDR      r1,|L2.72|
000034  05a0              LSLS     r0,r4,#22
000036  6008              STR      r0,[r1,#0]
;;;209    	NVIC_EnableIRQ(ADC_IRQn);
;;;210    
;;;211        /* Start ADC conversion */
;;;212        ADC_START_CONV(ADC);
000038  6820              LDR      r0,[r4,#0]
00003a  14e1              ASRS     r1,r4,#19
00003c  4308              ORRS     r0,r0,r1
00003e  6020              STR      r0,[r4,#0]
;;;213    	
;;;214    }
000040  bdf8              POP      {r3-r7,pc}
;;;215    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40043000
                  |L2.72|
                          DCD      0xe000e100

                          AREA ||i.ADC_ReadAVdd||, CODE, READONLY, ALIGN=2

                  ADC_ReadAVdd PROC
;;;142    
;;;143    void ADC_ReadAVdd(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;144    {
;;;145        int32_t  i32ConversionData;
;;;146        int32_t  i32BuiltInData;
;;;147    
;;;148        ADC_POWER_ON(ADC);
000002  4d22              LDR      r5,|L3.140|
000004  6828              LDR      r0,[r5,#0]
000006  2601              MOVS     r6,#1
000008  4330              ORRS     r0,r0,r6
00000a  6028              STR      r0,[r5,#0]
;;;149        CLK_SysTickDelay(10000);
00000c  4820              LDR      r0,|L3.144|
00000e  f7fffffe          BL       CLK_SysTickDelay
;;;150    
;;;151    	
;;;152        ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT29);
000012  4f1e              LDR      r7,|L3.140|
000014  05ac              LSLS     r4,r5,#22
000016  2200              MOVS     r2,#0
000018  3f80              SUBS     r7,r7,#0x80
00001a  4623              MOV      r3,r4
00001c  4611              MOV      r1,r2
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       ADC_Open
;;;153        ADC_SetExtendSampleTime(ADC, 0, 71);
000024  2247              MOVS     r2,#0x47
000026  2100              MOVS     r1,#0
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       ADC_SetExtendSampleTime
;;;154        ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
00002e  612e              STR      r6,[r5,#0x10]
;;;155        ADC_ENABLE_INT(ADC, ADC_ADF_INT);
000030  2101              MOVS     r1,#1
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       ADC_EnableInt
000038  4816              LDR      r0,|L3.148|
00003a  6004              STR      r4,[r0,#0]
;;;156        NVIC_EnableIRQ(ADC_IRQn);
;;;157        ADC_START_CONV(ADC);
00003c  6828              LDR      r0,[r5,#0]
00003e  14a1              ASRS     r1,r4,#18
000040  4308              ORRS     r0,r0,r1
000042  6028              STR      r0,[r5,#0]
;;;158    
;;;159        ADC_DISABLE_INT(ADC, ADC_ADF_INT);
000044  2101              MOVS     r1,#1
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       ADC_DisableInt
;;;160    		
;;;161        i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 29);
00004c  480f              LDR      r0,|L3.140|
00004e  3840              SUBS     r0,r0,#0x40
000050  6b40              LDR      r0,[r0,#0x34]
000052  b285              UXTH     r5,r0
;;;162        SYS_UnlockReg();
000054  f7fffffe          BL       SYS_UnlockReg
;;;163        FMC_Open();
000058  f7fffffe          BL       FMC_Open
00005c  480e              LDR      r0,|L3.152|
00005e  2104              MOVS     r1,#4
000060  60c1              STR      r1,[r0,#0xc]
000062  2170              MOVS     r1,#0x70
000064  6041              STR      r1,[r0,#4]
000066  6106              STR      r6,[r0,#0x10]
                  |L3.104|
000068  6902              LDR      r2,[r0,#0x10]
00006a  07d1              LSLS     r1,r2,#31
00006c  d1fc              BNE      |L3.104|
00006e  6880              LDR      r0,[r0,#8]
;;;164        i32BuiltInData = FMC_ReadBandGap();	
;;;165    
;;;166    	AVdd = 3072*i32BuiltInData/i32ConversionData;
000070  2103              MOVS     r1,#3
000072  0500              LSLS     r0,r0,#20
000074  0d00              LSRS     r0,r0,#20
000076  0289              LSLS     r1,r1,#10
000078  4348              MULS     r0,r1,r0
00007a  4629              MOV      r1,r5
00007c  f7fffffe          BL       __aeabi_idivmod
000080  4906              LDR      r1,|L3.156|
000082  6088              STR      r0,[r1,#8]  ; AVdd
000084  4803              LDR      r0,|L3.148|
000086  3080              ADDS     r0,r0,#0x80
000088  6004              STR      r4,[r0,#0]
;;;167    
;;;168    //	printf("%s : %d,%d,%d\r\n",__FUNCTION__,AVdd, i32ConversionData,i32BuiltInData);
;;;169    
;;;170        NVIC_DisableIRQ(ADC_IRQn);
;;;171    	
;;;172    }
00008a  bdf8              POP      {r3-r7,pc}
;;;173    
                          ENDP

                  |L3.140|
                          DCD      0x40043080
                  |L3.144|
                          DCD      0x00002710
                  |L3.148|
                          DCD      0xe000e100
                  |L3.152|
                          DCD      0x4000c000
                  |L3.156|
                          DCD      ||.data||

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;503      */
;;;504    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L4.28|
;;;505    {
;;;506        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L4.32|
000008  6148              STR      r0,[r1,#0x14]
;;;507        SysTick->VAL  = (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;508        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L4.18|
;;;509    
;;;510        /* Waiting for down-count to zero */
;;;511        while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L4.18|
;;;512    
;;;513        /* Disable SysTick counter */
;;;514        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;515    }
00001a  4770              BX       lr
;;;516    
                          ENDP

                  |L4.28|
                          DCD      CyclesPerUs
                  |L4.32|
                          DCD      0xe000e000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;215    
;;;216    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L5.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;219    }
00000c  bd10              POP      {r4,pc}
;;;220    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40004040

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;279    
;;;280    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;281    {
;;;282        /* Unlock protected registers */
;;;283        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;284    
;;;285        /* Enable HIRC clock (Internal RC 48MHz) */
;;;286        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;287    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;288    	
;;;289        /* Wait for HIRC clock ready */
;;;290        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;291    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;292    	
;;;293        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;294        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;295    
;;;296        /* Enable UART0 clock */
;;;297        CLK_EnableModuleClock(UART0_MODULE);
00001a  4c22              LDR      r4,|L6.164|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       CLK_EnableModuleClock
;;;298        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000022  2101              MOVS     r1,#1
000024  2200              MOVS     r2,#0
000026  0689              LSLS     r1,r1,#26
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CLK_SetModuleClock
;;;299    	
;;;300        CLK_EnableModuleClock(TMR3_MODULE);
00002e  4d1e              LDR      r5,|L6.168|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       CLK_EnableModuleClock
;;;301        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000036  2401              MOVS     r4,#1
000038  0564              LSLS     r4,r4,#21
00003a  2200              MOVS     r2,#0
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_SetModuleClock
;;;302    	
;;;303        CLK_EnableModuleClock(ADC_MODULE);	
000044  4d19              LDR      r5,|L6.172|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;304        CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL2_ADCSEL_PCLK1, CLK_CLKDIV0_ADC(2));
00004c  1162              ASRS     r2,r4,#5
00004e  4621              MOV      r1,r4
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       CLK_SetModuleClock
;;;305    
;;;306        /* Update System Core Clock */
;;;307        SystemCoreClockUpdate();
000056  f7fffffe          BL       SystemCoreClockUpdate
;;;308    
;;;309        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;310        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
00005a  0260              LSLS     r0,r4,#9
00005c  6bc1              LDR      r1,[r0,#0x3c]
00005e  22ff              MOVS     r2,#0xff
000060  0412              LSLS     r2,r2,#16
000062  4391              BICS     r1,r1,r2
000064  2233              MOVS     r2,#0x33
000066  0452              LSLS     r2,r2,#17
000068  1889              ADDS     r1,r1,r2
00006a  63c1              STR      r1,[r0,#0x3c]
;;;311                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;312    
;;;313        SYS->GPB_MFPH = (SYS->GPB_MFPH &~( SYS_GPB_MFPH_PB10MFP_Msk )) \
00006c  6bc1              LDR      r1,[r0,#0x3c]
00006e  220f              MOVS     r2,#0xf
000070  0212              LSLS     r2,r2,#8
000072  4391              BICS     r1,r1,r2
000074  31ff              ADDS     r1,r1,#0xff
000076  3101              ADDS     r1,#1
000078  63c1              STR      r1,[r0,#0x3c]
;;;314                        | ( SYS_GPB_MFPH_PB10MFP_ADC0_CH10) ;
;;;315    
;;;316        SYS->GPB_MFPL = (SYS->GPB_MFPL &~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB4MFP_Msk| SYS_GPB_MFPL_PB7MFP_Msk)) \
00007a  6b81              LDR      r1,[r0,#0x38]
00007c  4a0c              LDR      r2,|L6.176|
00007e  4011              ANDS     r1,r1,r2
000080  4a0c              LDR      r2,|L6.180|
000082  1889              ADDS     r1,r1,r2
000084  6381              STR      r1,[r0,#0x38]
;;;317                        | (SYS_GPB_MFPL_PB0MFP_ADC0_CH0 | SYS_GPB_MFPL_PB4MFP_ADC0_CH4| SYS_GPB_MFPL_PB7MFP_ADC0_CH7) ;
;;;318    
;;;319        /* Set PB.0 ~ PB.3 to input mode */
;;;320        GPIO_SetMode(PB, BIT0|BIT4|BIT7|BIT10, GPIO_MODE_INPUT);
000086  4c0d              LDR      r4,|L6.188|
000088  2200              MOVS     r2,#0
00008a  490b              LDR      r1,|L6.184|
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       GPIO_SetMode
;;;321    
;;;322        /* Disable the PB0 ~ PB3 digital input path to avoid the leakage current. */
;;;323        GPIO_DISABLE_DIGITAL_PATH(PB, BIT0|BIT4|BIT7|BIT10);
000092  6861              LDR      r1,[r4,#4]
000094  4a0a              LDR      r2,|L6.192|
000096  4311              ORRS     r1,r1,r2
000098  6061              STR      r1,[r4,#4]
00009a  490a              LDR      r1,|L6.196|
00009c  2000              MOVS     r0,#0
00009e  6008              STR      r0,[r1,#0]
;;;324    
;;;325        /* Lock protected registers */
;;;326        SYS_LockReg();
;;;327    }
0000a0  bd70              POP      {r4-r6,pc}
;;;328    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      0x5f803d10
                  |L6.168|
                          DCD      0x5f400005
                  |L6.172|
                          DCD      0x6743fe1c
                  |L6.176|
                          DCD      0x0ff0fff0
                  |L6.180|
                          DCD      0x10010001
                  |L6.184|
                          DCD      0x00000491
                  |L6.188|
                          DCD      0x40004040
                  |L6.192|
                          DCD      0x04910000
                  |L6.196|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L7.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L7.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L7.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L7.24|
                          DCD      0x40000100

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;253    
;;;254    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;255    {
;;;256        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L8.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;257        TIMER_EnableInt(TIMER3);
;;;258        NVIC_EnableIRQ(TMR3_IRQn);	
;;;259        TIMER_Start(TIMER3);
;;;260    }
000028  bd10              POP      {r4,pc}
;;;261    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40051020
                  |L8.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;220    
;;;221    void TMR3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4916              LDR      r1,|L9.92|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;222    {
00000a  d026              BEQ      |L9.90|
00000c  2301              MOVS     r3,#1
00000e  608b              STR      r3,[r1,#8]
;;;223    //	static uint32_t LOG = 0;
;;;224    	static uint16_t CNT = 0;
;;;225    	static uint16_t CNT_ADC = 0;
;;;226    	static uint8_t flag_num = 0;
;;;227    	
;;;228        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;229        {
;;;230            TIMER_ClearIntFlag(TIMER3);
;;;231    	
;;;232    		if (CNT++ >= 1000)
000010  4a13              LDR      r2,|L9.96|
000012  247d              MOVS     r4,#0x7d
000014  8890              LDRH     r0,[r2,#4]  ; CNT
000016  00e4              LSLS     r4,r4,#3
000018  1c41              ADDS     r1,r0,#1
00001a  8091              STRH     r1,[r2,#4]
00001c  2100              MOVS     r1,#0
00001e  42a0              CMP      r0,r4
000020  d304              BCC      |L9.44|
;;;233    		{		
;;;234    			CNT = 0;
;;;235    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;236    			PB14 ^= 1;
000022  4c10              LDR      r4,|L9.100|
000024  8091              STRH     r1,[r2,#4]            ;234
000026  6ba0              LDR      r0,[r4,#0x38]
000028  4058              EORS     r0,r0,r3
00002a  63a0              STR      r0,[r4,#0x38]
                  |L9.44|
;;;237    		}
;;;238    
;;;239    		if (CNT_ADC++ >= ADC_SAMPLETIME_MS)
00002c  88d0              LDRH     r0,[r2,#6]  ; CNT_ADC
00002e  1c43              ADDS     r3,r0,#1
000030  80d3              STRH     r3,[r2,#6]
000032  280a              CMP      r0,#0xa
000034  d311              BCC      |L9.90|
;;;240    		{		
;;;241    			CNT_ADC = 0;
000036  80d1              STRH     r1,[r2,#6]
;;;242    
;;;243    			aADCxCH = adc_data[flag_num].adc_ch;
000038  7810              LDRB     r0,[r2,#0]  ; flag_num
00003a  4b0b              LDR      r3,|L9.104|
00003c  0041              LSLS     r1,r0,#1
00003e  18cc              ADDS     r4,r1,r3
000040  7864              LDRB     r4,[r4,#1]
000042  8054              STRH     r4,[r2,#2]
;;;244    			flag_num = (flag_num >= adc_data[flag_num].idx) ? (0) : (flag_num + 1) ;
000044  5c59              LDRB     r1,[r3,r1]
000046  4281              CMP      r1,r0
000048  d801              BHI      |L9.78|
00004a  2000              MOVS     r0,#0
00004c  e000              B        |L9.80|
                  |L9.78|
00004e  1c40              ADDS     r0,r0,#1
                  |L9.80|
000050  7010              STRB     r0,[r2,#0]
;;;245    		
;;;246    			ADC_InitChannel(aADCxCH);
000052  8850              LDRH     r0,[r2,#2]  ; aADCxCH
000054  b2c0              UXTB     r0,r0
000056  f7fffffe          BL       ADC_InitChannel
                  |L9.90|
;;;247    
;;;248    		}
;;;249    		
;;;250        }
;;;251    }
00005a  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L9.92|
                          DCD      0x40051020
                  |L9.96|
                          DCD      ||.data||
                  |L9.100|
                          DCD      0x40004840
                  |L9.104|
                          DCD      ||.constdata||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;262    
;;;263    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;264    {
;;;265        SYS_ResetModule(UART0_RST);
000002  4813              LDR      r0,|L10.80|
000004  f7fffffe          BL       SYS_ResetModule
;;;266    
;;;267        /* Configure UART0 and set UART0 baud rate */
;;;268        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4811              LDR      r0,|L10.84|
00000e  f7fffffe          BL       UART_Open
;;;269    
;;;270    	/* Set UART receive time-out */
;;;271    //	UART_SetTimeoutCnt(UART0, 20);
;;;272    
;;;273    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000012  f7fffffe          BL       CLK_GetCPUFreq
000016  4601              MOV      r1,r0
000018  a00f              ADR      r0,|L10.88|
00001a  f7fffffe          BL       __2printf
;;;274    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001e  f7fffffe          BL       CLK_GetHXTFreq
000022  4601              MOV      r1,r0
000024  a013              ADR      r0,|L10.116|
000026  f7fffffe          BL       __2printf
;;;275    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00002a  f7fffffe          BL       CLK_GetLXTFreq
00002e  4601              MOV      r1,r0
000030  a016              ADR      r0,|L10.140|
000032  f7fffffe          BL       __2printf
;;;276    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  4601              MOV      r1,r0
00003c  a019              ADR      r0,|L10.164|
00003e  f7fffffe          BL       __2printf
;;;277    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000042  f7fffffe          BL       CLK_GetPCLK1Freq
000046  4601              MOV      r1,r0
000048  a01d              ADR      r0,|L10.192|
00004a  f7fffffe          BL       __2printf
;;;278    }
00004e  bd10              POP      {r4,pc}
;;;279    
                          ENDP

                  |L10.80|
                          DCD      0x04000010
                  |L10.84|
                          DCD      0x40070000
                  |L10.88|
000058  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00005c  4b5f4765
000060  74435055
000064  46726571
000068  203a2025
00006c  38640d0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L10.116|
000074  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000078  47657448
00007c  58544672
000080  6571203a
000084  20253864
000088  0d0a00  
00008b  00                DCB      0
                  |L10.140|
00008c  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000090  4765744c
000094  58544672
000098  6571203a
00009c  20253864
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L10.164|
0000a4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000a8  47657450
0000ac  434c4b30
0000b0  46726571
0000b4  203a2025
0000b8  38640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L10.192|
0000c0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000c4  47657450
0000c8  434c4b31
0000cc  46726571
0000d0  203a2025
0000d4  38640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.convertDecToBin||, CODE, READONLY, ALIGN=2

                  convertDecToBin PROC
;;;102    
;;;103    void convertDecToBin(int n)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;104    {
000002  b082              SUB      sp,sp,#8
;;;105        int k = 0;
000004  2500              MOVS     r5,#0
;;;106        unsigned char *p = (unsigned char*)&n;
000006  a802              ADD      r0,sp,#8
;;;107        int val2 = 0;
;;;108        int i = 0;
;;;109        for(k = 0; k <= 1; k++)
;;;110        {
;;;111            val2 = *(p+k);
;;;112            for (i = 7; i >= 0; i--)
;;;113            {
;;;114                if(val2 & (1 << i))
000008  2701              MOVS     r7,#1
00000a  9000              STR      r0,[sp,#0]
                  |L11.12|
00000c  9800              LDR      r0,[sp,#0]            ;111
00000e  2407              MOVS     r4,#7                 ;112
000010  5d46              LDRB     r6,[r0,r5]            ;111
                  |L11.18|
000012  4638              MOV      r0,r7
000014  40a0              LSLS     r0,r0,r4
000016  4230              TST      r0,r6
000018  d001              BEQ      |L11.30|
;;;115                    printf("1");
00001a  a007              ADR      r0,|L11.56|
00001c  e000              B        |L11.32|
                  |L11.30|
;;;116                else
;;;117                    printf("0");
00001e  a007              ADR      r0,|L11.60|
                  |L11.32|
000020  f7fffffe          BL       __2printf
000024  1e64              SUBS     r4,r4,#1
000026  d5f4              BPL      |L11.18|
;;;118            }
;;;119            printf(" ");
000028  a005              ADR      r0,|L11.64|
00002a  f7fffffe          BL       __2printf
00002e  1c6d              ADDS     r5,r5,#1
000030  2d01              CMP      r5,#1                 ;109
000032  ddeb              BLE      |L11.12|
;;;120        }
;;;121    }
000034  bdfe              POP      {r1-r7,pc}
;;;122    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
000038  3100              DCB      "1",0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L11.60|
00003c  3000              DCB      "0",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L11.64|
000040  2000              DCB      " ",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;336    
;;;337    int main()
000000  2400              MOVS     r4,#0
;;;338    {
;;;339    	uint8_t idx = 0;
;;;340    	uint16_t adc_data = 0;	
;;;341    
;;;342        SYS_Init();
000002  f7fffffe          BL       SYS_Init
;;;343    
;;;344        UART0_Init();
000006  f7fffffe          BL       UART0_Init
;;;345    
;;;346    	GPIO_Init();
00000a  f7fffffe          BL       GPIO_Init
;;;347    
;;;348    	TIMER3_Init();
00000e  f7fffffe          BL       TIMER3_Init
;;;349    
;;;350        /* Enable ADC converter */
;;;351        ADC_POWER_ON(ADC);
000012  4910              LDR      r1,|L12.84|
000014  6808              LDR      r0,[r1,#0]
000016  2201              MOVS     r2,#1
000018  4310              ORRS     r0,r0,r2
00001a  6008              STR      r0,[r1,#0]
;;;352    
;;;353        /*Wait for ADC internal power ready*/
;;;354        CLK_SysTickDelay(10000);
00001c  480e              LDR      r0,|L12.88|
00001e  f7fffffe          BL       CLK_SysTickDelay
;;;355    
;;;356        /* Got no where to go, just loop forever */
;;;357        while(1)
;;;358        {
;;;359    		#if 1
;;;360    		adc_data = ADCxConvertedData[idx];
000022  4e0e              LDR      r6,|L12.92|
;;;361    //		convertDecToBin(adc_data);
;;;362    		printf("0x%2X:0x%3X(%4dmv)," , idx , adc_data , ADC_CALC_DATA_TO_VOLTAGE(adc_data,ADC_REF_VOLTAGE));
000024  4f0e              LDR      r7,|L12.96|
                  |L12.38|
000026  0060              LSLS     r0,r4,#1              ;360
000028  5a35              LDRH     r5,[r6,r0]            ;360
00002a  480e              LDR      r0,|L12.100|
00002c  4639              MOV      r1,r7
00002e  4368              MULS     r0,r5,r0
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4603              MOV      r3,r0
000036  462a              MOV      r2,r5
000038  4621              MOV      r1,r4
00003a  a00b              ADR      r0,|L12.104|
00003c  f7fffffe          BL       __2printf
;;;363    
;;;364    		if (idx++ >= 3)
000040  4620              MOV      r0,r4
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4
000046  2803              CMP      r0,#3
000048  d3ed              BCC      |L12.38|
;;;365    		{
;;;366    			printf("\r\n");
00004a  a00c              ADR      r0,|L12.124|
00004c  f7fffffe          BL       __2printf
;;;367    			idx = 0;
000050  2400              MOVS     r4,#0
000052  e7e8              B        |L12.38|
;;;368    		}
;;;369    //		idx = (idx++ >= 3) ? (0) : (idx) ;
;;;370    		
;;;371    		#else
;;;372    		convertDecToBin(adc_value1);
;;;373    		printf(" 0x%4X , %4dmv " , adc_value1 , ADC_CALC_DATA_TO_VOLTAGE(adc_value1,ADC_REF_VOLTAGE));
;;;374    		printf("      ");
;;;375    		convertDecToBin(adc_value2);	
;;;376    		printf(" 0x%4X , %4dmv\r\n" , adc_value2, ADC_CALC_DATA_TO_VOLTAGE(adc_value2,ADC_REF_VOLTAGE));
;;;377    		#endif
;;;378        }
;;;379    }
;;;380    
                          ENDP

                  |L12.84|
                          DCD      0x40043080
                  |L12.88|
                          DCD      0x00002710
                  |L12.92|
                          DCD      ||.data||+0xc
                  |L12.96|
                          DCD      0x00000fff
                  |L12.100|
                          DCD      0x00000ce4
                  |L12.104|
000068  30782532          DCB      "0x%2X:0x%3X(%4dmv),",0
00006c  583a3078
000070  25335828
000074  2534646d
000078  76292c00
                  |L12.124|
00007c  0d0a00            DCB      "\r\n",0
00007f  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  adc_data
000000  01000204          DCB      0x01,0x00,0x02,0x04
000004  0307040a          DCB      0x03,0x07,0x04,0x0a
000008  ff10              DCB      0xff,0x10

                          AREA ||.data||, DATA, ALIGN=2

                  flag_num
000000  0000              DCB      0x00,0x00
                  aADCxCH
000002  0000              DCW      0x0000
                  ||CNT||
000004  0000              DCW      0x0000
                  CNT_ADC
000006  0000              DCW      0x0000
                  AVdd
                          DCD      0x00000000
                  ADCxConvertedData
00000c  0000              DCW      0x0000
00000e  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=0

                          EXPORTAS ||area_number.18||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_adc_data____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_adc_data____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_adc_data____REVSH|
#line 402
|__asm___6_main_c_adc_data____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
